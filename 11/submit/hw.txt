機械ソフトウェア演習　宿題
第11回
学籍番号 : 340192C
井上　裕太

[感想]
ポインタのいい復習になったと思う。冬休み競技プログラミングの問題をかなり解いたので見たことがあるような問題が多く解きやすかったと思う。
できれば、データ構造のついでにグラフとの関連についても話して欲しかった。
宿題
宿題1
[mon1.c]
#include<stdio.h>
#include<stdlib.h>

typedef struct list_struct{
  int data;
  struct list_struct *next;
}LIST;

LIST head;

void addlist(void);
void showlist(void);
void deletelist(void);
int main(void){
  char command, buf[40];

  head.next = NULL;

  do{
    printf("comm? a:add d:delete p:print q:quit\n");
    fgets(buf, sizeof(buf), stdin);
    sscanf(buf, "%c", &command);

    switch(command){
    case 'a':
      addlist();
      showlist();
      break;
    case 'p':
      showlist();
      break;
    case 'd':
      deletelist();
      showlist();
      break;
    case 'q':
      break;
    default:
      printf("error\n");
      break;
    }
  }while(command != 'q');

  return 0;
}

void addlist(void){
  LIST *p, *q, *newcell;
  int data;
  char buf[40];

  printf("data ? \n");
  fgets(buf, sizeof(buf), stdin);
  sscanf(buf, "%d", &data);

  /* TODO 1 */
  p = head.next;
  q=&head;
  while(1){
    if(p==NULL)break;
    if(data >= q->data && data <= p->data)break;
    q = p;
    p = q->next;
  }

  newcell = (LIST*)malloc(sizeof(LIST));/* TODO 2 */;
  if(newcell == NULL){
    printf("mem err\n");
    return;
  }

  /* TODO 3 */
  newcell->next = q->next;
  newcell->data = data;
  q->next = newcell;
}

void deletelist(){
  LIST *p,*q,*r;
  int data;
  char buf[40];

  printf("data ? \n");
  fgets(buf, sizeof(buf), stdin);
  sscanf(buf,"%d",&data);

  p = head.next;
  q = &head;
  r = &head;
  while(1){
    if(p==NULL){
      printf("Sorry, there is no such data %d\n",data);
      return;
    }
    if(data==q->data)break;
    r = q;
    q = p;
    p = q->next;
  }
  q->next = NULL;
  r->next = p;
}

void showlist(void){
  LIST *p;

  printf("\nlist \n");
  /* TODO 4 */
  p = head.next;

  while(1){
    printf("%d\n",p->data);
    if(p->next==NULL)break;
    p = p->next;
  }
}

[command]
gcc mon1.c -o mon1 -lm
./mon1

[input]
comm? a:add d:delete p:print q:quit
a
data ?
300

list
300
comm? a:add d:delete p:print q:quit
a
data ?
100

list
100
300
comm? a:add d:delete p:print q:quit
a
data ?
20

list
20
100
300
comm? a:add d:delete p:print q:quit
d
data ?
300
Sorry, there is no such data 300

list
20
100
300
comm? a:add d:delete p:print q:quit
d
data ?
10
Sorry, there is no such data 10


[考察]
課題2とほぼ同じコードである。
deletelist()については、addlist()で前->新しい要素->後とつなぎかえたのに対し、
前->後
削除する要素
の形で、削除対象の要素への辺を削除することで実装した。
こちらもwhile(true)の形式で実装を行い、内部状況に応じた処理をするようにコードを設計した。

宿題
宿題2
[mon2.c]
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<unistd.h>
#define SIZE_X 30
#define SIZE_Y 50
char field[SIZE_X][SIZE_Y],next_field[SIZE_X][SIZE_Y]; // 盤
int generation;
void init();
int count(int x,int y);
bool die_s(int x,int y);
bool generate_s(int x,int y);
void next_generation();
void copy_array();
void display();
int main(){
  generation = 0;
  init();
  while(1){
    display();
    next_generation();
    sleep(1);
    generation++;
  }
}

void init(){
  int i,j;
  for(i=0;i<SIZE_X;i++)
    for(j=0;j<SIZE_Y;j++)field[i][j] = '.';
  field[6][20] = field[6][21] = '*';
  field[7][19] = field[7][20] = '*';
  field[8][20] = '*';
}

void display(){
  int i,j;
  for(i=0;i<30;i++){
    printf("\n");
  }
  printf("Generation %d\n",generation);
  for(i=0;i<SIZE_X;i++){
    for(j=0;j<SIZE_Y;j++){
      printf("%c",field[i][j]);
    }
    printf("\n");
  }
}

void next_generation(){
  int i,j;
  for(i=0;i<SIZE_X;i++){
    for(j=0;j<SIZE_Y;j++){
      if(field[i][j]=='.'){
        if(generate_s(i,j))next_field[i][j]='*';
        else next_field[i][j]='.';
      } else {
        if(die_s(i,j))next_field[i][j]='.';
        else next_field[i][j]='*';
      }
    }
  }
  copy_array();
}

bool die_s(int x,int y){
  int cnt = count(x,y);
  return (cnt <= 1 || cnt >= 4);
}

bool generate_s(int x,int y){
    int cnt = count(x,y);
    return (cnt == 3);
}

int count(int x,int y){
  int i,j,nx,ny,cnt=0;
  for(i=-1;i<=1;i++){
    for(j=-1;j<=1;j++){
      nx = x + i,ny = y + j;
      if(nx >= 0 && nx < 50 && ny >= 0 && ny < 50 && field[nx][ny]=='*')cnt++;
    }
  }
  if(field[x][y]=='*')cnt--;
  return cnt;
}

void copy_array(){
  int i,j;
  for(i=0;i<SIZE_X;i++)
    for(j=0;j<SIZE_Y;j++)field[i][j]=next_field[i][j];
}

[command]
gcc life.c -o life -lm
./life

[output]
Generation 0
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
....................**............................
...................**.............................
....................*.............................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................






























Generation 1
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
...................***............................
...................*..............................
...................**.............................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................






























Generation 2
..................................................
..................................................
..................................................
..................................................
..................................................
....................*.............................
...................**.............................
..................*..*............................
...................**.............................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................






























Generation 3
..................................................
..................................................
..................................................
..................................................
..................................................
...................**.............................
...................***............................
..................*..*............................
...................**.............................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................






























Generation 4
..................................................
..................................................
..................................................
..................................................
..................................................
...................*.*............................
..................*..*............................
..................*..*............................
...................**.............................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................
..................................................


[考察]
当初、盤を配列ではなくポインタとして実装していたが、動作がサンプルと異なり非常に苦労した。
現在の盤から次の盤へ更新を行う作業で、二回目以降（field=next_field）を行ったタイミングで指しているオブジェクト自体が同じになってしまっているという初歩的なミスに気がつかなかったため早期に生物が全滅してしまっていた。
コード内部で工夫した点としては、周辺探査ようにメソッドを用意し使いまわしたことでコード量自体がかなり落とせたことだと考える。
sleep()については、実行環境に依存するがunix環境という仮定のもとで実装した。（本来であれば時刻基準のほうが…いいのかもしれないですが…）